# FibRowTranspositionEncrypt
# Key generation:
We will initially have the plain text written row wise in a predefined matrix, lets say 3X3 for an example.
Once this is done, a key will be generated from the Fibonacci series, 

The format of the key:

    • [NO OF TERMS | START TERM | DIMENSION OF THE MATRIX]
    
    • So for example if we write : 643 
    
    • It means we will be using 6 terms starting with 4th term of the series and the matrix we use is of dimension 3X3
    
    • Therefore for encryption we use derived key 3 5 8 13 21 34 
    
    • Now to make sure these numbers can be used for transposition in a 3X3 matrix we need to make sure they are a number less than or equal to 3 thus we will take the modulus of each term.
    
    • New derived key – 0 2 2 1 0 1
    
    • As we can see 0 -refers to first column 1- to the first column and 2- to the second column
    
    • Now we will take these numbers in pairs so 
    
    • New derived key – 02 21 01
    
    • The intuition of this key is column shifting this means exchange the first and third column, then in the new matrix exchange third and second column then exchange first and second column.
    
# KEY GENERATION ALGORTIHM:

The key will be generated in 3 steps:

The first part k1, will be a NONZERO random number greater than 2 generated by the function RAND function in MATLAB and other softwares. (LENGTH OF k1 is L1)

The second part k2, will also be NONZERO random number which will hold the number of terms of Fibonacci to be taken, this will also be generated using the random function RAND of softwares  (LENGTH OF K2 is L2)

Both k1 and k2 are integers, non zero. (By L1 and L2 we mean no of digits)

The third part of the key, k3 will be generated using the length of the plain text to be encrypted, 

K3=SQUAREROOT(lengthOfPlainText)

In case of non perfect squares, the ceiling value of the root is taken, thus 

K3=CEIL(SQRT(LengthOfPlainText)).

To make K3 more random, we take average of L1 and L2 and use the ceiling function again

K3=CEIL(AVG(L1,L2))

The final key which is sent as L1L2L3 and K1K2K3 to receivers side as public key.

Public key implies that the user (receivers side) and the (senders side) use the same key for encryption and decryption.

The key generation has only basic computation (addition and subtraction and one string function length) thus it is computationally inexpensive for this algorithm which we will try to prove later in this paper.



# ENCRYPTION:

For example we use – a sample matrix – [ 1 2 3;4 5 6;7 8 9] 

In this if we perform the above operations we get [1 3 2; 4 6 5;7 9 8]

Now this matrix is used to written column wise (while writing it is written row wise) so we get – CIPHER – 147369258

PLAIN – 123456789
• In case of odd number of terms, we ignore the last digit so as to make pairs.
    
# DECRYPTION:

While retrieving the plain text from cipher text we will key again, we write down the derived key and using string techniques we will reverse the entire text and redo the entire proves in reverse order as we need to follow the exact same sequence in reverse order.

So for example we get the key:

    • 643
    
    • We derive the derived key by writing 6 terms of Fibonacci series starting from 4th term.
    
    • Thus we get 3 5 8 13 21 34, 
    
    • Now we modulus this series by 3 as our matrix dimension is of size 3.
    
    • Now we get  0 2 2 1 0 1
    
    • Next we reverse the order of this sequence 1 0 1 2 2 0
    
    • Now we create the pairs 10 12 20
    
    • And using each pair do the same column transform as before.
    
    • After all three pairs of transforms are done we write down each element of the final matrix (ROW WISE) ad we can see the original text back!
    
